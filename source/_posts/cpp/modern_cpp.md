---
title:  "Modern CPP"
date:   2021-03-18
categories: CPP
---

## Language Enhancements

### C++11 Tail Type Inference(Deprecated in C++14)

```cpp
// 1. `auto` cannot be used for function arguments for type derivation. 
// traditional C++
template <typename R, typename T, typename U>
R Add(T x, U y) {
    return x + y;
}
// 2. C++11. decltype(x + y). 
// error: x and y have not been defined when the compiler reads decltype(x + y).
template <typename T, typename U>
decltype(x + y) Add(T x, U y) {
    return x + y;
}
// 3. Tail Type Inference
template <typename T, typename U>
auto Add(T x, U y) -> decltype(x + y) {
    return x + y;
}
// 4. C++14
template <typename T, typename U>
auto Add(T x, U y)
{
    return x + y;
}
```

### Range based for loop

```cpp
for (auto element: vec) // readonly
for (auto& element: vec) // writable
```

### Strongly typed enumerations

`enum class : (integral type int by default) {};`

```cpp
enum class new_enum : unsigned int {
    value1,
    value2,
    value3 = 100,
    value4 = 100,
};

template <typename T>
std::ostream& opreator<< (
    typename std::enable_if<
        std::is_enum<T>::value, std::ostream>::type& stream, T e) {
    return stream << static_cast<typename std::underlying_type<T>::type>(e);
}
```

### RValue Reference

* lvalue: value to the left of the assignment symbol.
* rvalue: value to the right of the assignment symbol.
          Temporary object no longer exists after the expression ends.

C++11, `rvalue reference` divides rvalue into:

1. pure rvalue:
   temporary variables returned by non-references;
   temporary variables generated by operation expressions;
   original literals;
   lambda expressions;

2. xvalue(expire value):
   a temporary value that can be identified while being able to be moved.

### Literal

* `Raw String` `R"()"`

```cpp
// * Raw String Literal `R"()"`
std::string path = "C:\\Path\\To\\File";
std::string raw_path = R"(C:\Path\To\File)";
```

* `Custom Literal`

```cpp
// * Custom Literal by overloading the double quotes suffix operator:
//   Custom Literal support four literals:
//   1. Integer literal: (unsigned long long, const char*)
//   2. Floating-point literals: (long double, const char*)
//   3. String literals: (const char *, size_t )
//   4. Character literals: (char/wchar_t/char16_t, char32_t)
std::string operator"" _wow1(const char* wow1, size_t len) {
    return std::string(wow1) + "woooooooooooow, amazing";
}
std::string operator"" _wow2(unsigned long long i) {
    return std::to_string(i) + "woooooooooooow, amazing";
}
```

### Tuples

* `std::make_tuple; std::get<n>; std::tie(a, b, c)`
* `std::tuple_cat; std::tuple_size`

```cpp
int main() {
    // std::make_tuple
    auto student = std::make_tuple(3.8, 'A', "John");

    // std::get
    std::cout << std::get<0>(student) << std::endl;

    // std::tie
    double gpa;
    char grade;
    std::string name;
    std::tie(gpa, grade, name) = student;
    std::cout << gpa << grade << name << std::endl;

    // std::tuple_cat
    auto new_tuple = std::tuple_cat(tuple1, tuple2);

    // std::tuple_size<T>
    std::cout << std::tuple_size<decltype(new_type)>::value << std::endl;
}
```

* Runtime Indexing

```cpp
template <size_t n, typename... T>
constexpr std::variant<T...> _tuple_index(const std::tuple<T...> &tpl,
                                          size_t i) {
  if constexpr (n >= sizeof...(T))
    throw std::out_of_range(" .");
  if (i == n)
    return std::variant<T...>{std::in_place_index<n>, std::get<n>(tpl)};
  return _tuple_index<(n < sizeof...(T) - 1 ? n + 1 : 0)>(tpl, i);
}

template <typename... T>
constexpr std::variant<T...> tuple_index(const std::tuple<T...> &tpl,
                                         size_t i) {
  return _tuple_index<0>(tpl, i);
}
int main()  {
  int index = 1;
  std::cout << tuple_index(num_tuple, index) << std::endl;
  auto &&value = tuple_index(num_tuple, index);
}
```

### `constexpr`

```cpp
template <typename T>
auto print_type_info(const T& t) {
    if constexpr (std::is_integral<T>::value) {
        return t + 1;
    } else {
        return t + 0.001;
    }
}
```

### `noexcept`

C++11 simplifies exception declarations into two cases:

```cpp
void may_throw();   // May throw any exception
void no_throw() noexcept; // Cannot throw any exception

std::cout << std::boolalpha << "may_thorow() noexcept? " << noexcept(may_throw()) << std::endl;
```

If a function modified with `noexcept` is thrown, the compiler will use `std::terminate()` to immediately terminate the program.

`noexcept` can also be used as an `operator` to manipulate an expression.

### `alignof`, `alignas`, `std::max_align_t`

```cpp
struct alignas(std::max_align_t) AlignasStorage {
    char a;
    int  b;
    double c;
    long long d;
};
std::cout << alignof(AlignasStorage) << std::endl;
```

## Template

### Extern Template

* Traditional: templates are instantiated by the compiler only when they are used.
* C++11: explicitly tell the compiler when to instantiate the template.

```cpp
template class std::vector<bool>; // force instantiation.
extern template class std::vector<double>; // should not instantiation in current file.
```

### Deduction for class templates

Class template argument deduction is only performed if no template argument list is present.

* Implicitly-generated deduction guides
* Deduction for alias templates
* `User-defined deduction guides`

`explicit-specifier(optional) template-name(parameter-declaration-clause) -> simple-template-id`

```cpp
// struct.
template <class... Ts> struct overloaded : Ts... { using Ts::operator()...; };

// trailing return function.
// explicit deduction guide (not needed as of C++20)
template <class... Ts> overloaded(Ts...) -> overloaded<Ts...>;

using var_t = std::variant<int, long, double, std::string>;

int main() {
    std::vector<var_t> vec = { 10, 15l, 1.5, "hello" };

    for (auto& v: vec) {
        std::visit(overloaded {
            [](auto arg) { std::cout << arg << ' '; },
            [](double arg) { std::cout << std::fixed << arg << ' '; },
            [](const std::string& arg) { std::cout << std::quoted(arg) << ' '; },  
        }, v);
    }
}
```

### Variadic Templates

* Unpacking template parameters

```cpp
// 1. Recursive template function
template <typename T0>
void printf1(T0 value) {
    std::cout << value << std::endl;
}
template <typename T, typename... Ts>
void printf1(T value, Ts... args) {
    std::cout << value << std::endl;
    printf1(args...);
}
// 2. Variable parameter template expansion
template <typename T0, typename... T>
void printf2(T0 t0, T... t) {
    std::cout << t0 << std::endl;
    if constexpr (sizeof...(t) > 0)
        printf2(t...);
}
// 3. Initialize list expansion
template <typename T, typename... Ts>
auto printf3(T value, Ts.. args) {
    std::cout << value << std::endl;
    (void) std::initialize_list<T> { ([&args] {
        std::cout << args << std::endl;
    }(), value)...};
}
```

### Fold Expression

```cpp
template <typename... T>
auto sum(T... t) {
    return (t + ...);
}
```

### `decltype And std::declval<T>`

`declval` is commonly used in templates where acceptable template parameters may have `no constructor` in common, but have the same member function whose `return type` is needed.

```cpp
template <typename T, typename U>
auto Add(T x, U y) -> decltype(x+y) {
    return x + y;
}

// std::declval<T>

struct Default
{
    int foo() const { return 1; }
};

struct NoDefault
{
    NoDefault() = delete;
    int fool() const { return 1; }
};

decltype(Default().foo()) n1 = 1;
// decltype(NoDefault().fool()) n2 = n1; // error: no default constructor.
decltype(std::declval<NoDefault>().foo()) n2 = n1; // ok. no constructor needed.
```

### `std::forward<T>`

## Concurrency

* `RAII` guarantees the exceptional security of the code while keep the simplicity of the code.
* `std::atomic<T>::is_lock_free`
* `std::future` can be used to get the results of asynchronous tasks.

```cpp
std::packaged_task<int()> task([]() { return 7; })
std::future<int> result = task.get_future();
```

### Atomic and Memory Order

`Memory Order` is not only about atomic operations but also operations before/after atomic operations.

* relaxed: single thread sequential. between different threads is `arbitrary`.
* release/consume: similar to release/acquire, but is data dependencies.
* release/acquire: all writes before release are visible to any other thread.
* sequential: atomic operations satisfy sequence consistency.

## Regular Expression

* `(,)` Marks the start and end of a subexpression. Subexpression can be obtained for later use.
* `[,]` Marks the start and end of a bracket expression.
* `{,}` Marks the start and end of a qualifier expression.
